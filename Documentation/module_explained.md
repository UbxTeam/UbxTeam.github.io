---
layout: page
title: Module Explained
---

In ubx context, a ___module___ is a special shared object having three functions to allow
[dynamic loading](http://en.wikipedia.org/wiki/Dynamic_loading) at runtime.

* ___module init function:___ responsible for __registering__ type and/or block prototypes into the current __node__.
* ___module cleanup function:___ responsible for __deregistering__ type and/or block prototypes
* ___module license:___ unique string identifier to the module license, conforms to the Software Package Data Exchange [SPDX](http://spdx.org/).
The list of the identifiers can be found [here](http://spdx.org/licenses/).

At runtime, a module can be __loaded__, thus executing the init function. After that, the node knows the type/block prototypes contained in the module
and different block __instances__ can be created from a prototype.
Similarly, when __unloading__ a module, all the prototypes related to that module are cleaned up and removed. This operation is always executed when terminating
an ubx node instances, but can also be manually called if you want to replace a block prototype with another at runtime.

The previous signatures are mandatory and they can be generated by the following MACROs, respectively:

* UBX_MODULE_INIT
* UBX_MODULE_CLEANUP
* UBX_MODULE_LICENSE_SPDX


In general, a module contains one or more type and/or block prototype implementations that are registered/deregistered 
with a node when the module is loaded/unloaded.
However, it is a suggested practice to generate a separate module for new datatype and block implementations, since
most of the time datatype definitions are shared/re-used by different blocks.
It is up to the block developer to determine the level of granularity for putting more blocks into a single module. 
A criteria to consider is related to the licensing and distribution of the blocks: to distribuite a (collection of) block(s) you may want to
release only the module and not the sources, with related SPDX license attached to it. That allows to group block prototypes in accordance with
their licenses, since there is only a license for a module.

___Note:___ The dynamic loading mechanism is the only portion of the whole Ubx reference implementation that is OS-dependent.
Currently, only Unix-like systems are supported.

## Module in the code

To better understand what a module is and how to implement one, let's take the [cblock_tutorial_auto](https://github.com/UbxTeam/ubx_tutorials/tree/master/cblock_tutorial_auto) 
example obtained from the tutorial ["My first cblock in C ( with tools! )"](/Tutorials/c_example_with_auto/c_example_with_auto).

__Note:__ If you did not follow the mentioned tutorial yet, may be you would like to give it a try! If not, just browse into the code.

Compiling the sources in [cblock_tutorial_auto](https://github.com/UbxTeam/ubx_tutorials/tree/master/cblock_tutorial_auto), we obtain three modules, 
as specified by the [package model](https://github.com/UbxTeam/ubx_tutorials/blob/master/cblock_tutorial_auto/models/cblock_tutorial_auto.pkg)

* Module __sendermod__, contains the prototype of the block _sender_
* Module __receivermod__, contains the prototype of the block _receiver_
* Module __cblock_tutorial_auto_types__, contains the type _my_data_

At deployment time, these modules are imported into the ubx node (see field _imports_ in the [cblock_tutorial_auto.usc](https://github.com/UbxTeam/ubx_tutorials/blob/master/cblock_tutorial_auto/cblock_tutorial_auto.usc) ).

In the subfolder [modules](https://github.com/UbxTeam/ubx_tutorials/tree/master/cblock_tutorial_auto/modules), 
you can find the implementation for the first two modules (_sendermod_ and _receivermod_).

The header file [sendermod_module.h](https://github.com/UbxTeam/ubx_tutorials/blob/master/cblock_tutorial_auto/modules/sendermod_module.h) defines the signatures by the provided
MACROs. 
{% highlight c %}
/*
 * module function declaration for module sendermod header (autogenerated)
 */
 
#include <ubx.h>

// Initialization and cleanup function declaration
int sendermod_mod_init(ubx_node_info_t* ni);
void sendermod_mod_cleanup(ubx_node_info_t* ni);


/* declare module init and cleanup functions, so that the ubx core can
 * find these when the module is loaded/unloaded.
 * Please edit your license in macro LICENSE_SPDX */
UBX_MODULE_INIT(sendermod_mod_init)
UBX_MODULE_CLEANUP(sendermod_mod_cleanup)
UBX_MODULE_LICENSE_SPDX(GPL-2.0+)
{% endhighlight %}
The MACROs take the function to execute as argument, while these functions declaration (sendermod_mod_init_ and sendermod_mod_cleanup_) must have 
the following signatures:

___INIT___
{% highlight c %}
int (ubx_node_info_t* ni);
{% endhighlight %}
___CLEANUP___
{% highlight c %}
void (ubx_node_info_t* ni);
{% endhighlight %}
while the name of the function is not relevant.

Their implementations are in the source [sendermod_module.c](https://github.com/UbxTeam/ubx_tutorials/blob/master/cblock_tutorial_auto/modules/sendermod_module.c).
{% highlight c %}
/*
 * module function declaration for library sendermod header (autogenerated)
 */

#include "sendermod_module.h"

int sendermod_mod_init(ubx_node_info_t* ni)
{
  int ret;
  ret=sender_mod_init(ni);
  if(ret!=0)
    goto out;

out:
   return ret;
}

void sendermod_mod_cleanup(ubx_node_info_t* ni)
{
  sender_mod_cleanup(ni);
}
{% endhighlight %}

Since the implementations of _sendermod_mod_init_ and _sendermod_mod_cleanup_ call only the init and cleanup function of the _sender_ block, that means only the 
prototype of the block _sender_ will be _registered_(_deregistered_) once the library is _loaded_(_unloaded_).

Finally, the module for the types is defined in the source [cblock_tutorial_auto.c](https://github.com/UbxTeam/ubx_tutorials/blob/master/cblock_tutorial_auto/types/cblock_tutorial_auto_types.c).

__Note:__ The previous example is generated with ubx_tools. which is taking care to create the sources for the modules for you.
However, you can mix types and blocks prototype implementation, and write our own Makefile or CMakefileList.txt. For instance, you could prefer to
generate only one module for both _my_data_, _sender_ and _receiver_.

__Exercise:__ Try to implement manually a new module called _senderreceivermod_ containing both _sender_ and _receiver_ cblocks!
